# Документация по использованному синтаксису

## 1. Самовызывающаяся функция (IIFE - Immediately Invoked Function Expression)

```javascript
(function() {
    // Ваш код здесь
})();
```

### Что это такое?

Самовызывающаяся функция — это функция, которая вызывается сразу же после того, как она была определена. Такая функция создаёт собственную область видимости, изолируя переменные и функции внутри неё от глобальной области видимости.

### Зачем это нужно?

- **Изоляция кода**: Предотвращает конфликт имён переменных и функций с другими частями кода или сторонними библиотеками.
- **Чистая глобальная область видимости**: Уменьшает вероятность случайного перезаписывания глобальных переменных.

### Как это работает?

- Функция определяется в виде выражения `(function() { ... })`.
- Круглые скобки вокруг функции превращают её в функциональное выражение.
- Сразу после определения функция вызывается с помощью `()`.

---

## 2. Классы в JavaScript

```javascript
class ClassName {
    constructor(parameters) {
        // Инициализация объекта
    }

    methodName(parameters) {
        // Метод класса
    }
}
```

### Что это такое?

Классы в JavaScript — это синтаксический сахар над прототипным наследованием. Они позволяют создавать шаблоны объектов с определёнными свойствами и методами.

### Зачем это нужно?

- **Организация кода**: Делает код более структурированным и читаемым.
- **Повторное использование**: Позволяет создавать множество объектов с одинаковыми свойствами и методами.
- **Наследование**: Поддерживает создание подклассов, которые наследуют свойства и методы родительских классов.

### Основные компоненты класса:

- **`constructor`**: Специальный метод, который вызывается при создании нового экземпляра класса с помощью `new ClassName()`. Здесь инициализируются свойства объекта.
- **Методы**: Функции, определённые внутри класса, которые будут доступны экземплярам класса.

---

## 3. Деструктуризация объектов

```javascript
const { property1, property2 = defaultValue } = options;
```

### Что это такое?

Деструктуризация — это синтаксис, позволяющий извлекать значения из объектов или массивов и присваивать их переменным.

### Зачем это нужно?

- **Удобство**: Позволяет писать более короткий и понятный код.
- **Прозрачность**: Явно показывает, какие свойства используются из объекта.

### Как это работает?

- **Извлечение свойств**: Вы можете извлечь свойства объекта и присвоить их переменным с тем же именем.
- **Значения по умолчанию**: Если свойство отсутствует в объекте, можно задать значение по умолчанию.

**Пример:**

```javascript
const options = { name: 'Example' };
const { name, activeClass = 'default' } = options;
```

- `name` получит значение `'Example'`.
- `activeClass` получит значение `'default'`, так как в `options` нет такого свойства.

---

## 4. Шаблонные строки (Template literals)

```javascript
const message = `Привет, ${name}!`;
```

### Что это такое?

Шаблонные строки — это способ создавать строки, который позволяет вставлять в них переменные и выражения.

### Зачем это нужно?

- **Интерполяция**: Легко вставлять значения переменных внутрь строк.
- **Многострочные строки**: Можно создавать строки, занимающие несколько строк кода, без специальных символов.

### Как это работает?

- Используются обратные кавычки `` ` `` вместо обычных `'` или `"`.
- Переменные и выражения вставляются внутрь `${}`.

**Пример:**

```javascript
const a = 5;
const b = 10;
console.log(`Сумма ${a} и ${b} равна ${a + b}.`);
// Выведет: Сумма 5 и 10 равна 15.
```

---

## 5. Стрелочные функции

```javascript
const func = (parameters) => {
    // Тело функции
};
```

### Что это такое?

Стрелочные функции — это более краткий синтаксис для написания функций в JavaScript.

### Зачем это нужно?

- **Сокращение кода**: Меньше кода для объявления функций.
- **Удобство в использовании**: Особенно полезно для кратких функций и коллбеков.
- **Отсутствие собственного `this`**: У стрелочных функций нет своего `this`, что может быть полезно или требовать внимания.

### Как это работает?

- Стрелочные функции объявляются с помощью оператора `=>`.
- Если функция содержит только одно выражение, можно опустить фигурные скобки и ключевое слово `return`.

**Примеры:**

- **Без параметров:**

  ```javascript
  const greet = () => {
      console.log('Привет!');
  };
  ```

- **С одним параметром:**

  ```javascript
  const square = x => x * x;
  // То же самое, что:
  // const square = (x) => { return x * x; };
  ```

- **С несколькими параметрами:**

  ```javascript
  const add = (a, b) => a + b;
  ```

---

## 6. Методы работы с DOM (Document Object Model)

### Что это такое?

DOM — это программный интерфейс для HTML и XML документов. Он представляет страницу в виде дерева узлов, что позволяет языкам программирования взаимодействовать с содержимым и структурой веб-страницы.

### Основные методы:

#### **`document.querySelectorAll`**

```javascript
const elements = document.querySelectorAll('selector');
```

- **Описание**: Находит все элементы в документе, соответствующие заданному CSS-селектору.
- **Возвращает**: Коллекцию (NodeList) найденных элементов.

**Пример:**

```javascript
const buttons = document.querySelectorAll('.my-button');
```

#### **`element.addEventListener`**

```javascript
element.addEventListener('click', function() {
    // Ваш код здесь
});
```

- **Описание**: Добавляет обработчик события к элементу.
- **Аргументы**:
  - Тип события (например, `'click'`, `'input'`).
  - Функция, которая будет вызвана при наступлении события.

**Пример:**

```javascript
button.addEventListener('click', () => {
    console.log('Кнопка нажата!');
});
```

---

## 7. Работа с классами элементов

### Что это такое?

Элементы на веб-странице могут иметь атрибут `class`, который используется для определения стилей и поведения элементов. С помощью JavaScript можно динамически добавлять или удалять классы у элементов.

### Основные методы:

#### **`classList.add`**

```javascript
element.classList.add('className');
```

- **Описание**: Добавляет указанный класс к элементу.
- **Результат**: Элемент будет иметь новый класс, что может изменить его стиль или поведение.

#### **`classList.remove`**

```javascript
element.classList.remove('className');
```

- **Описание**: Удаляет указанный класс из элемента.

#### **`classList.contains`**

```javascript
if (element.classList.contains('className')) {
    // Ваш код здесь
}
```

- **Описание**: Проверяет, содержит ли элемент указанный класс.
- **Возвращает**: `true`, если класс присутствует, иначе `false`.

---

## 8. Работа с атрибутами `data-*`

### Что это такое?

Атрибуты `data-*` позволяют хранить дополнительные данные в HTML-элементах без использования нестандартных атрибутов или дополнительных DOM-свойств.

### Как это работает?

- **HTML-элемент с атрибутом `data-*`:**

  ```html
  <div data-value="example"></div>
  ```

- **Доступ к значению атрибута в JavaScript:**

  ```javascript
  const element = document.querySelector('div');
  const value = element.dataset.value; // 'example'
  ```

- **`dataset`**: Свойство `dataset` элемента предоставляет доступ к всем его атрибутам `data-*` в виде объекта.

---

## 9. Объект `Set`

```javascript
const mySet = new Set();
```

### Что это такое?

`Set` — это встроенный объект в JavaScript, который позволяет хранить уникальные значения любого типа, будь то примитивы или объекты.

### Зачем это нужно?

- **Хранение уникальных значений**: Автоматически удаляет дубликаты.
- **Быстрые операции поиска**: Проверка наличия элемента происходит быстро.

### Основные методы:

- **`add(value)`**: Добавляет значение в множество.

  ```javascript
  mySet.add(1);
  mySet.add(2);
  ```

- **`has(value)`**: Проверяет, содержится ли значение в множестве.

  ```javascript
  mySet.has(1); // true
  mySet.has(3); // false
  ```

- **`delete(value)`**: Удаляет значение из множества.

  ```javascript
  mySet.delete(2);
  ```

- **Перебор элементов**:

  ```javascript
  mySet.forEach(value => {
      console.log(value);
  });
  ```

- **Преобразование в массив**:

  ```javascript
  const array = Array.from(mySet);
  ```

---

## 10. Преобразование коллекций в массивы

### Зачем это нужно?

Некоторые методы возвращают коллекции, которые не являются массивами (например, `NodeList` из `querySelectorAll` или `Set`). Чтобы использовать методы массивов, такие как `map`, `filter`, `reduce`, необходимо преобразовать эти коллекции в массивы.

### Как это сделать?

#### **`Array.from`**

```javascript
const array = Array.from(collection);
```

- **Описание**: Создаёт новый массив из подобного массиву или итерируемого объекта.

**Пример:**

```javascript
const buttons = document.querySelectorAll('button');
const buttonsArray = Array.from(buttons);
```

---

## 11. Сортировка массивов

```javascript
array.sort();
```

### Что это такое?

Метод `sort` сортирует элементы массива на месте и возвращает отсортированный массив.

### Как это работает?

- Без аргументов `sort` преобразует элементы в строки и сортирует их в порядке Unicode.

**Пример:**

```javascript
const numbers = [3, 1, 4, 1, 5];
numbers.sort();
console.log(numbers); // [1, 1, 3, 4, 5]
```

- Для числовой сортировки рекомендуется передавать функцию сравнения:

  ```javascript
  numbers.sort((a, b) => a - b);
  ```

---

## 12. Метод `join` для массивов

```javascript
const str = array.join(separator);
```

### Что это такое?

Метод `join` объединяет все элементы массива в строку, разделяя их указанным разделителем.

### Как это работает?

- **`separator`**: Необязательный параметр. Если не указан, элементы разделяются запятой `,`.
- Если указан пустой разделитель `''`, элементы соединяются без промежутков.

**Пример:**

```javascript
const letters = ['a', 'b', 'c'];
const word = letters.join(''); // 'abc'
```

---

## 13. Условные операторы

### Что это такое?

Условные операторы позволяют выполнять разные участки кода в зависимости от условий.

### Основной синтаксис:

```javascript
if (condition) {
    // Код, если условие истинно
} else if (anotherCondition) {
    // Код, если другое условие истинно
} else {
    // Код, если ни одно из условий не истинно
}
```

### Как это работает?

- **`condition`**: Выражение, которое возвращает `true` или `false`.
- Если `condition` истинно (`true`), выполняется код внутри `{ }` после `if`.
- Если нет, проверяется `anotherCondition` и т.д.
- Блок `else` выполняется, если все предыдущие условия ложны.

**Пример:**

```javascript
const age = 18;
if (age >= 18) {
    console.log('Взрослый');
} else {
    console.log('Несовершеннолетний');
}
```

---

## 14. Оператор строгого равенства `===`

```javascript
if (a === b) {
    // Ваш код здесь
}
```

### Что это такое?

Оператор `===` сравнивает два значения на строгое равенство, без приведения типов.

### Как это работает?

- Возвращает `true`, если значения равны и имеют одинаковый тип.
- В отличие от `==`, не выполняет преобразование типов.

**Пример:**

```javascript
0 == false;  // true
0 === false; // false
```

- В первом случае `0` приводится к `false`, поэтому результат `true`.
- Во втором случае сравниваются разные типы (`number` и `boolean`), результат `false`.

---

## 15. Объект `Error`

```javascript
throw new Error('Сообщение об ошибке');
```

### Что это такое?

Объект `Error` используется для создания пользовательских ошибок.

### Зачем это нужно?

- **Обработка ошибок**: Позволяет сигнализировать о проблемах, которые возникли во время выполнения программы.
- **Отладка**: Предоставляет информацию об ошибке, которую можно использовать для исправления кода.

### Как это работает?

- **Создание ошибки**:

  ```javascript
  const error = new Error('Что-то пошло не так');
  ```

- **Выброс ошибки**:

  ```javascript
  throw error;
  ```

- **Обработка ошибок с помощью `try...catch`**:

  ```javascript
  try {
      // Код, который может вызвать ошибку
  } catch (e) {
      // Обработка ошибки
      console.error(e.message);
  }
  ```

**Пример:**

```javascript
function divide(a, b) {
    if (b === 0) {
        throw new Error('Деление на ноль невозможно');
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    console.error(e.message); // 'Деление на ноль невозможно'
}
```